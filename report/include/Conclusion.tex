% CREATED BY DAVID FRISK, 2016
\chapter{Conclusion}

% You may consider to instead divide this chapter into discussion of the
% results and a summary.

% TODO START HERE
% Write something at all here.


% TODO write something about soruce-level transpilation vs. logic level. When
% translating a proof from one system to another it is possible to model features
% of the source system in the target system. But when transpilng source-level
% that is much harder. If I transpiled at the logic level I could have
% implemented universe polymorhpism in Idris. Now I have to rely on the Idris
% built in features. That makes it harder. And makes it novel.

\section{Results}

\todo{This section is only a placeholder for now.}
We have created a tool which translates Idris source code into Agda. The
resulting Agda code can compile and work probably if the Idris source don't use
most language feature.

However Agda and Idris handles universe levels differently so code which relies
on universe cumulativley won't work in Agda. The transpiler doesen't account
for universe levels so int only works on level 1 which is something else.


\section{Discussion}
The utility of transpiler between Agda and Idris is obvious. It has the
possibility of removing a lot of duplicated effort for the developers.
Especially the reuse of libraries and proofs between systems is very valuble.
This is evident from the vast number of previous works in this area, and the
whole reason for projects like Dedukti.~\cite{assaf2016dedukti}

The value of a source-to-source transpiler which produces human readable ouput
is more unclear though. The use case where one wants to continue a started work
in another language is a narrower.

It is certanly possible to construct the transpiler. It only requiers a big
effort before it is a useful tool. Most of the problems are software
engineering problems and not in the logic. But diferences in the foundation
make certain corner cases untranslatable.

The choice to re-use the main Idris and Agda implementation for the frontend
and backend of the transpiler respektivly should be evaluated. While it allows
for feature parity with the main-line implemnetation and other perks, it
significantly slows development. We have sunk much time into mainly the Idris
codebase. A real-world compiler does a lot of things and are very
complex.\todo{no general statements, talk about Idris} It is possible that we
whould have gotten further if we would have developed the frontend parser from
scratch. But it is impossible to know. It took a lot of time which is not of
value for the academic project, but will be useful for eventual real-world use.


% TODO Write about further research.
\subsection{Further research}
\todod{lang}
There is still a lot to do. There are many more features of Idris which would
need to be implemented for the transpiler to handle most real-world programs.
The next logical step would be to implement bi-directional transpiling. Both
from Idris to Agda and from Agda to Idris. That however, has its own set of
challenges, only parts can be reused from this project.

An interesting side project would be to re-use the implicit argument conversion
as a refactoring tool. Refactoring for dependently typed languages are not very
well researched. But some ideas are in~\cite{wibergh2019}. There is some
overlap in the transpiler and refactoring. Both tools work with and rearrange
the concrete syntax, possibly using information from other compilation steps.


\section{Conclusion}

\todo{flesh out}
This project show that it is possible to construct
a useful transpiler. To construct a perfect one however is not possible within
a reasonable amount of work. It is probably not possible to construct a perfect
one with out basically implementing the soruce language in the target language.
Idris and Agda are very similar though and the common subset is perfectly
usable.

This project also show where Idris and Agda differ, this is useful for
comparing the lanugagres and programmers switching from one to the other.

As part of the transpiler we have written source code transformation which
could be useful for automatic refactoring tools. That is one of the main take
away from this.



